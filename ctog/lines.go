package ctog

import (
	"strings"

	"github.com/invopop/gobl/bill"
	"github.com/invopop/gobl/cbc"
	"github.com/invopop/gobl/l10n"
	"github.com/invopop/gobl/num"
	"github.com/invopop/gobl/org"
	"github.com/invopop/gobl/tax"
)

func (c *Converter) prepareLines(tsct *SupplyChainTradeTransaction) error {
	items := tsct.IncludedSupplyChainTradeLineItem
	lines := make([]*bill.Line, 0, len(items))

	for _, it := range items {
		price, err := num.AmountFromString(it.SpecifiedLineTradeAgreement.NetPriceProductTradePrice.ChargeAmount)
		if err != nil {
			return err
		}
		l := &bill.Line{
			// Index is generated by GOBL
			//If Quantity is not present, assume 1
			Quantity: num.MakeAmount(1, 0),
			Item: &org.Item{
				Name:  it.SpecifiedTradeProduct.Name,
				Price: price,
			},
			Taxes: tax.Set{
				{
					Category: cbc.Code(it.SpecifiedLineTradeSettlement.ApplicableTradeTax.TypeCode),
				},
			},
		}

		if it.SpecifiedLineTradeDelivery != nil {
			l.Quantity, err = num.AmountFromString(it.SpecifiedLineTradeDelivery.BilledQuantity.Value)
			if err != nil {
				return err
			}
		}

		if it.SpecifiedLineTradeDelivery.BilledQuantity.UnitCode != "" {
			l.Item.Unit = unitFromUNECE(cbc.Code(it.SpecifiedLineTradeDelivery.BilledQuantity.UnitCode))
		}

		if it.SpecifiedTradeProduct.SellerAssignedID != nil {
			l.Item.Ref = *it.SpecifiedTradeProduct.SellerAssignedID
		}
		if it.SpecifiedTradeProduct.BuyerAssignedID != nil {
			if l.Item.Identities == nil {
				l.Item.Identities = make([]*org.Identity, 0)
			}
			l.Item.Identities = append(l.Item.Identities, &org.Identity{
				Code: cbc.Code(*it.SpecifiedTradeProduct.BuyerAssignedID),
			})
		}

		if it.SpecifiedTradeProduct.GlobalID != nil {
			if l.Item.Identities == nil {
				l.Item.Identities = make([]*org.Identity, 0)
			}
			l.Item.Identities = append(l.Item.Identities, &org.Identity{
				// This label corresponds to a code from the ISO 6523 ICD List. Mapping is not yet supported
				Label: it.SpecifiedTradeProduct.GlobalID.SchemeID,
				Code:  cbc.Code(it.SpecifiedTradeProduct.GlobalID.Value),
			})
		}

		if it.SpecifiedTradeProduct.Description != nil {
			l.Item.Description = *it.SpecifiedTradeProduct.Description
		}

		if it.SpecifiedTradeProduct.OriginTradeCountry != nil {
			l.Item.Origin = l10n.ISOCountryCode(it.SpecifiedTradeProduct.OriginTradeCountry.ID)
		}

		if len(it.AssociatedDocumentLineDocument.IncludedNote) > 0 {
			l.Notes = make([]*cbc.Note, 0, len(it.AssociatedDocumentLineDocument.IncludedNote))
			for _, note := range it.AssociatedDocumentLineDocument.IncludedNote {
				n := &cbc.Note{}
				if note.Content != "" {
					n.Text = note.Content
				}
				if note.ContentCode != "" {
					n.Code = note.ContentCode
				}
				l.Notes = append(l.Notes, n)
			}
		}

		if it.SpecifiedLineTradeSettlement.ApplicableTradeTax.RateApplicablePercent != "" {
			if !strings.HasSuffix(it.SpecifiedLineTradeSettlement.ApplicableTradeTax.RateApplicablePercent, "%") {
				it.SpecifiedLineTradeSettlement.ApplicableTradeTax.RateApplicablePercent += "%"
			}
			p, err := num.PercentageFromString(it.SpecifiedLineTradeSettlement.ApplicableTradeTax.RateApplicablePercent)
			if err != nil {
				return err
			}
			l.Taxes[0].Percent = &p
		}

		if it.SpecifiedLineTradeSettlement.SpecifiedTradeAllowanceCharge != nil {
			l, err = getLineCharges(it.SpecifiedLineTradeSettlement.SpecifiedTradeAllowanceCharge, l)
			if err != nil {
				return err
			}
		}

		if it.SpecifiedLineTradeSettlement.ReceivableSpecifiedTradeAccountingAccount != nil {
			if l.Notes == nil {
				l.Notes = make([]*cbc.Note, 0)
			}
			l.Notes = append(l.Notes, &cbc.Note{
				Text: it.SpecifiedLineTradeSettlement.ReceivableSpecifiedTradeAccountingAccount.ID,
			})
			if it.SpecifiedLineTradeSettlement.ReceivableSpecifiedTradeAccountingAccount.TypeCode != nil {
				for i, note := range l.Notes {
					if note.Text == it.SpecifiedLineTradeSettlement.ReceivableSpecifiedTradeAccountingAccount.ID {
						l.Notes[i].Key = cbc.Key(*it.SpecifiedLineTradeSettlement.ReceivableSpecifiedTradeAccountingAccount.TypeCode)
						break
					}
				}
			}
		}

		if it.SpecifiedTradeProduct.DesignatedProductClassification != nil {
			for _, c := range it.SpecifiedTradeProduct.DesignatedProductClassification {
				l.Item.Identities = append(l.Item.Identities, &org.Identity{
					Label: c.ClassCode.ListID,
					Code:  cbc.Code(c.ClassCode.Value),
				})
			}
		}

		if it.SpecifiedTradeProduct.ApplicableProductCharacteristic != nil {
			l.Item.Meta = make(cbc.Meta)
			for _, char := range it.SpecifiedTradeProduct.ApplicableProductCharacteristic {
				key := formatKey(char.Description)
				l.Item.Meta[key] = char.Value
			}
		}

		lines = append(lines, l)
	}

	c.inv.Lines = lines
	return nil
}

// getLineCharges parses inline charges and discounts from the CII document
func getLineCharges(alwcs []*SpecifiedTradeAllowanceCharge, l *bill.Line) (*bill.Line, error) {
	for _, ac := range alwcs {
		if ac.ChargeIndicator.Indicator {
			c, err := getLineCharge(ac)
			if err != nil {
				return nil, err
			}
			if l.Charges == nil {
				l.Charges = make([]*bill.LineCharge, 0)
			}
			l.Charges = append(l.Charges, c)
		} else {
			d, err := getLineDiscount(ac)
			if err != nil {
				return nil, err
			}
			if l.Discounts == nil {
				l.Discounts = make([]*bill.LineDiscount, 0)
			}
			l.Discounts = append(l.Discounts, d)
		}
	}
	return l, nil
}
